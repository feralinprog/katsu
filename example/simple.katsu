pretty-print: 10 + 20

let: (adder: (n0: Fixnum)) do: [
    mut: n = n0
    let: delta = n0 + 30
    \x [
        let: new-n = n + delta + x
        n: new-n
        n
    ]
]

let: a = (adder: 3)
pretty-print: a
pretty-print: (a call: 0) # 3 + 33 + 0 = 36
pretty-print: (a call: 2) # 36 + 33 + 2 = 71

pretty-print: 5 type
pretty-print: a type
a instance?: Fixnum
a instance?: Closure

print: "this is " ~ "a test"

let: (if: (cond: Bool) then: tbody else: fbody) do: [
    # TODO: `then:else:` should always tail-call -- it just needs to know whether it's tail position or not.
    TAIL-CALL: (cond then: tbody else: fbody)
]

let: (if: (cond: Bool) then: tbody) do: [
    # TODO: `then:else:` should always tail-call -- it just needs to know whether it's tail position or not.
    TAIL-CALL: (cond then: tbody else: null)
]

let: (while: (cond: Closure) do: (body: Closure)) do: [
    # TODO: `then:else:` should always tail-call -- it just needs to know whether it's tail position or not.
    TAIL-CALL: ((cond call) then: [
        body call
        TAIL-CALL: (while: cond do: body)
    ] else: null)
]

let: run-test do: [
    mut: n = 10000
    while: [n > 0] do: [
        if: (n / 10000) * 10000 = n then: [
            pretty-print: n
        ]
        n: n - 1
    ]
]
(null) run-test

data: Point has: { x; y }
data: Point3D extends: { Point } has: { z }
let: p = (Point3D x: 1 y: 2 z: 3)
p .x
p .y
p .z
(p x: 5; null)
(p y: 6; null)
(p z: 7; null)
p .x
p .y
p .z

p Point?
p Point3D?

(Point x: 1 y: 2) Point3D?

data: Optional has: {}
data: OptionalSome extends: { Optional } has: { value }
data: OptionalNone extends: { Optional } has: {}

let: (some: value) do: [ OptionalSome value: value ]
let: none          do: [ OptionalNone new ]

let: ((opt: OptionalSome) then: some-body else: none-body) do: [
    some-body call: opt .value
]
let: ((opt: OptionalNone) then: some-body else: none-body) do: [
    none-body call
]

(some: 5) then: [pretty-print: it] else: [print: "none"]
(null none) then: [pretty-print: it] else: [print: "none"]

let: (signal: thing) do: [
    pretty-print: thing
]

# let: ((opt: Optional) value!) do: [
#     opt then: [it] else: [signal: (NoneValue message: "none has no value")]
# ]
# 
# (null none) value!

pretty-print: {1; 2; 3}

let: ((n: Fixnum) times: body) do: [
    mut: i = 0
    while: [i < n] do: [
        body call: i
        i: i + 1
    ]
]

5 times: [pretty-print: it]

let: (v: Vector) length do: [
    v unsafe-read-u64-at-offset: 1
]

let: v = {1;2;3;4}
v length
pretty-print: v
v unsafe-write-value-at-offset: 2 value: "I swappa the arrey"
pretty-print: v


let: (f: n) do: [
    (null) get-call-stack
]
let: (g: n) do: [
    f: n
]
let: (h: n) do: [
    g: n
]
let: s = (h: 0)

let: (segment: CallSegment) length do: [
    segment unsafe-read-u64-at-offset: 1
]

data: Frame has: { segment; offset }
let: ((frame: Frame) unsafe-read-u64-at-offset: (offset: Fixnum)) do: [
    frame .segment unsafe-read-u64-at-offset: (2 + frame .offset + offset)
]
let: ((frame: Frame) unsafe-read-value-at-offset: (offset: Fixnum)) do: [
    frame .segment unsafe-read-value-at-offset: (2 + frame .offset + offset)
]
let: (frame: Frame) .code do: [
    frame unsafe-read-value-at-offset: 1
]
let: (frame: Frame) .inst-spot do: [
    frame .segment unsafe-read-u32-at-offset: (2 + frame .offset + 2) * 2
]
let: (frame: Frame) .#regs do: [
    frame unsafe-read-u64-at-offset: 3
]
let: (frame: Frame) .#data do: [
    frame unsafe-read-u64-at-offset: 4
]
let: (frame: Frame) .data-depth do: [
    frame unsafe-read-u64-at-offset: 5
]
let: (frame: Frame) .module do: [
    frame unsafe-read-value-at-offset: 6
]
let: (frame: Frame) .marker do: [
    frame unsafe-read-value-at-offset: 7
]
let: (frame: Frame) next do: [
    Frame segment: frame .segment offset: (
        frame .offset + 8 + frame .#regs + frame .#data
    )
]

pretty-print: s length
let: fm = (Frame segment: s offset: 0)
print: "MODULE FRAME:"
pretty-print: fm .code
pretty-print: fm .inst-spot
pretty-print: fm .#regs
pretty-print: fm .#data
pretty-print: fm .data-depth
#pretty-print: fm .module

let: fh = fm next
print: "'h' FRAME:"
pretty-print: fh .code
pretty-print: fh .inst-spot
pretty-print: fh .#regs
pretty-print: fh .#data
pretty-print: fh .data-depth
#pretty-print: fm .module

let: fg = fh next
print: "'g' FRAME:"
pretty-print: fg .code
pretty-print: fg .inst-spot
pretty-print: fg .#regs
pretty-print: fg .#data
pretty-print: fg .data-depth
#pretty-print: fm .module

let: ff = fg next
print: "'f' FRAME:"
pretty-print: ff .code
pretty-print: ff .inst-spot
pretty-print: ff .#regs
pretty-print: ff .#data
pretty-print: ff .data-depth
#pretty-print: fm .module

let: (code: Code) .module do: [
    code unsafe-read-value-at-offset: 1
]
let: (code: Code) .#params do: [
    code unsafe-read-u32-at-offset: 2 * 2
]
let: (code: Code) .#regs do: [
    code unsafe-read-u32-at-offset: 2 * 2 + 1
]
let: (code: Code) .#data do: [
    code unsafe-read-u32-at-offset: 3 * 2
]
let: (code: Code) .upreg-map do: [
    code unsafe-read-value-at-offset: 4
]
let: (code: Code) .insts do: [
    code unsafe-read-value-at-offset: 5
]
let: (code: Code) .args do: [
    code unsafe-read-value-at-offset: 6
]
let: (code: Code) .span do: [
    code unsafe-read-value-at-offset: 7
]
let: (code: Code) .inst-spans do: [
    code unsafe-read-value-at-offset: 8
]

let: c = ff .code
print: "'f' CODE:"
pretty-print: c .module type
pretty-print: c .#params
pretty-print: c .#regs
pretty-print: c .#data
pretty-print: c .upreg-map
pretty-print: c .insts
pretty-print: c .args
pretty-print: c .span
pretty-print: c .inst-spans

let: (t: Tuple) length do: [
    t unsafe-read-u64-at-offset: 1
]
let: ((t: Tuple) unsafe-at: (i: Fixnum)) do: [
    t unsafe-read-value-at-offset: 2 + i
]

let: (a: Array) length do: [
    a unsafe-read-u64-at-offset: 1
]
let: ((a: Array) unsafe-at: (i: Fixnum)) do: [
    a unsafe-read-value-at-offset: 2 + i
]

let: tup = (1, 2, 3)
pretty-print: tup length
pretty-print: (tup unsafe-at: 0)
pretty-print: (tup unsafe-at: 1)
pretty-print: (tup unsafe-at: 2)

data: SourceLocation has: { index; line; column }
data: SourceSpan has: { file; start; end }
let: (t: Tuple) >SourceSpan do: [
    SourceSpan file: (t unsafe-at: 0) start: (
        SourceLocation index: (t unsafe-at: 1) line: (t unsafe-at: 2) column: (t unsafe-at: 3)
    ) end: (
        SourceLocation index: (t unsafe-at: 4) line: (t unsafe-at: 5) column: (t unsafe-at: 6)
    )
]

let: digit-strings = ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9")
let: (n: Fixnum) digit>string do: [
    digit-strings unsafe-at: n
]

let: ((a: Fixnum) mod: (n: Fixnum)) do: [ a - (a / n) * n ]

print: "-----------------"

let: (s: String) >string do: [ s ]
let: (n: Fixnum) >string do: [
    n < 0 then: ["-" ~ (- n) >string] else: [
        n < 10 then: [n digit>string] else: [
            (n / 10) >string ~ (n mod: 10) digit>string
        ]
    ]
]
let: (_: Null) >string do: ["null"]
let: (b: Bool) >string do: [b then: "t" else: "f"]

let: (span: SourceSpan) >string do: [
    "<" ~ span .file ~ ":" ~ (
        (span .start .line + 1) >string ~ ":" ~ (span .start .column + 1) >string
    ) ~ "-" ~ (
        (span .end .line + 1) >string ~ "." ~ (span .end .column + 1) >string
    ) ~ ">"
]

let: i = 12
print: ((Frame segment: (null) get-call-stack offset: 0) .code .inst-spans unsafe-at: i) >SourceSpan >string


print: "----------------------------------"

print: "aaaaa"
[
    print: "  bbbbb"
    let: input = (\k [
        print: "    ccccc"
        print: "    result of k('abcdef'): " ~ (k call: "abcdef")
        print: "    result of k('123456'): " ~ (k call: "123456")
        print: "    ddddd"
    ] call/dc: t)
    print: "  eeeee"
    # Pretend to do some calculations, and return the result:
    "calcs(" ~ input ~ ")"
] call/marked: t
print: "zzzzz"

print: "----------------------------------"

let: (shift: f) do: [ f call/marked: t ]
let: (reset: f) do: [ f call/dc: t ]

let: f with-return do: [
    shift: [
        f call: \v [ reset: [v] ]
    ]
]

print: (\return [
    print: "doing some things"
    return call: "early return"
    print: "oops, after return!"
] with-return)

print: "----------------------------------"

let: (f cleanup: c) do: [
    [ f call ] call/marked: t
    c call
]

\r [
    print: "doing some setup"
    [
        print: "doing some calcs"
        r call
        print: "after early return - shouldn't see this at all"
    ] cleanup: [
        print: "cleaning up!"
    ]
    print: "after cleanup - also shouldn't see this, since early return should still be active"
] with-return

let: m1 = "marker 1"
let: m2 = "marker 2"
[
    [
        [
            print: "escaping to marker"
        ] call/dc: m1
        print: "after call/dc: m1"
    ] call/marked: m2
    print: "after call/marker: m2"
] call/marked: m1
print: "after call/marker: m1"