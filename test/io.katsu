use: {
    "core.builtin.ffi"
    "core.builtin.misc"
    "core.dynamic-variable"
    "core.ffi"
    "core.io"
    "core.io.linux.error"
    "core.io.linux.file"
    "core.io.linux.socket"
    "core.io.stream"
    "core.resource"
    "core.sequence"
}

with-io: [
    try: [
        %open: "file-does-not-exist" flags: O_RDONLY
    ] except: {
        IOError, \c [
            print: "got IO error: " ~ c .message
        ]
    }

    with-input-stream: (open-input/blocking: "test/files/file1.txt") do: [
        let: s = read-all byte-array>string
        print: s
    ]

    # Do it again, but with a ridiculously small group size for reading. Make sure each group
    # is incorporated correctly.
    with-input-stream: (open-input: "test/files/file1.txt") do: [
        let: s = (read-all/group: 1 like: *input-stream* get buffer-exemplar) byte-array>string
        print: s
    ]

    let: nl = " "
    nl unsafe-write-u8-at-offset: 16 value: 10

    print: "writing to stdout:"
    write-from: ("abcde" ~ nl) string>byte-array

    print: "writing to stderr:"
    with-output-stream*: *error-stream* get do: [
        write-from: ("fake-err" ~ nl) string>byte-array
    ]

    # We should've closed other file descriptors automatically.
    assert: (%socket: AF_INET type: SOCK_STREAM protocol: 0) = 4
]
