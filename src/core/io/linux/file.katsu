use: {
    "core.builtin.ffi"
    "core.builtin.misc"
    "core.dynamic-variable"
    "core.ffi"
    "core.io.linux.epoll"
    "core.io.linux.errno"
    "core.io.linux.error"
    "core.io.linux.handle"
    "core.io.linux.scheduler"
    "core.io.stream"
    "core.resource"
    "core.sequence"
}

# =============== libc wrapper functions: ====================
# Note that these are only valid while within a with-io block;
# outside, these wrapper functions will refer to uninitialized
# or already-disposed FFI resources.

# TODO: most of these should be defined instead by baking in the libffi CIF, and also the malloc'ed regions
# for args and return values.

let: &open = new-CIFRef
let: (%open: (pathname: String) flags: (flags: Fixnum) mode: (mode: Fixnum)) do: [
    # TODO: somehow get rid of the >c-string ^dispose pattern.
    with-disposal: [
        (&open .args at: 0) foreign-write-foreign-at-offset: 0 value: pathname >c-string ^dispose
        (&open .args at: 1) foreign-write-sint-at-offset: 0 value: flags
        (&open .args at: 2) foreign-write-uint-at-offset: 0 value: mode
        (&open ffi-call foreign-read-sint-at-offset: 0) %check-syscall
    ]
]
# Default to mode = 0.
let: (%open: (pathname: String) flags: (flags: Fixnum)) do: [ %open: pathname flags: flags mode: 0 ]

# TODO: hex / octal integers

# Access modes:
let: O_RDONLY = 0
let: O_WRONLY = 1
let: O_RDWR   = 2

# File creation flags:
let: O_CLOEXEC   = 524288 # 02000000
let: O_CREAT     = 64 # 0100
let: O_DIRECTORY = 65536 # 0200000
let: O_EXCL      = 128 # 0200
let: O_NOCTTY    = 256 # 0400
let: O_NOFOLLOW  = 131072 # 0400000
let: O_TMPFILE   = (4194304 bit|: O_DIRECTORY) # 020000000 | O_DIRECTORY
let: O_TRUNC     = 512 # 01000

# File status flags:
let: O_APPEND    = 1024 # 02000
let: O_ASYNC     = 8192 # 020000
let: O_DIRECT    = 16384 # 040000
let: O_DSYNC     = 4096 # 010000
# let: O_LARGEFILE = 0
let: O_NOATIME   = 262144 # 01000000
let: O_NONBLOCK  = 2048 # 04000
let: O_NDELAY    = 2048 # 04000
let: O_PATH      = 2097152 # 010000000
let: O_SYNC      = 1052672 # 04010000

# TODO: define the mode bits
# let: S_IXOTH = 
# let: S_IWOTH = 
# let: S_IROTH = 
# let: S_IRWXO = 
# let: S_IXGRP = 
# let: S_IWGRP = 
# let: S_IRGRP = 
# let: S_IRWXG = 
# let: S_IXUSR = 
# let: S_IWUSR = 
# let: S_IRUSR = 
# let: S_IRWXU = 
# let: S_ISVTX = 
# let: S_ISGID = 
# let: S_ISUID = 

let: &read = new-CIFRef
let: ((fd: Fixnum) %read: (buf: ByteArray) count: (count: Fixnum) at: (offset: Fixnum)) do: [
    (&read .args at: 0) foreign-write-sint-at-offset: 0 value: fd
    (&read .args at: 2) foreign-write-size_t-at-offset: 0 value: count
    # Set the `buf` arg late, since we must avoid GC moving the underlying byte array in memory.
    let: _buf = (&read .args at: 1)
    _buf foreign-write-foreign-at-offset: 0 value: (buf byte-array>foreign/offset: offset)
    (&read ffi-call foreign-read-ssize_t-at-offset: 0) %check-syscall
]

let: &write = new-CIFRef
let: ((fd: Fixnum) %write: (buf: ByteArray) count: (count: Fixnum) at: (offset: Fixnum)) do: [
    (&write .args at: 0) foreign-write-sint-at-offset: 0 value: fd
    (&write .args at: 2) foreign-write-size_t-at-offset: 0 value: count
    # Set the `buf` arg late, since we must avoid GC moving the underlying byte array in memory.
    let: _buf = (&write .args at: 1)
    _buf foreign-write-foreign-at-offset: 0 value: (buf byte-array>foreign/offset: offset)
    (&write ffi-call foreign-read-ssize_t-at-offset: 0) %check-syscall
]

# Bit of a special case: the third argument to fcntl can change type depending on the value of the
# second argument (`op`).
let: &fcntl<void> = new-CIFRef
let: &fcntl<int> = new-CIFRef
let: &fcntl<ptr> = new-CIFRef
let: ((fd: Fixnum) %fcntl: (op: Fixnum)) do: [
    (&fcntl<void> .args at: 0) foreign-write-sint-at-offset: 0 value: fd
    (&fcntl<void> .args at: 1) foreign-write-sint-at-offset: 0 value: op
    (&fcntl<void> ffi-call foreign-read-sint-at-offset: 0) %check-syscall
]
let: ((fd: Fixnum) %fcntl: (op: Fixnum) arg: (arg: Fixnum)) do: [
    (&fcntl<int> .args at: 0) foreign-write-sint-at-offset: 0 value: fd
    (&fcntl<int> .args at: 1) foreign-write-sint-at-offset: 0 value: op
    (&fcntl<int> .args at: 2) foreign-write-sint-at-offset: 0 value: arg
    (&fcntl<int> ffi-call foreign-read-sint-at-offset: 0) %check-syscall
]
let: ((fd: Fixnum) %fcntl: (op: Fixnum) arg: (arg: Foreign)) do: [
    (&fcntl<ptr> .args at: 0) foreign-write-sint-at-offset: 0 value: fd
    (&fcntl<ptr> .args at: 1) foreign-write-sint-at-offset: 0 value: op
    (&fcntl<ptr> .args at: 2) foreign-write-foreign-at-offset: 0 value: arg
    (&fcntl<ptr> ffi-call foreign-read-sint-at-offset: 0) %check-syscall
]

# TODO: there are a bunch more -- add support for other fcntl ops.
let: F_DUPFD = 0
let: F_GETFD = 1
let: F_SETFD = 2
let: F_GETFL = 3
let: F_SETFL = 4
let: F_DUPFD_CLOEXEC = 1030

# Must be called from within a with-disposal: block.
let: setup-file-syscalls do: [
    let: libc = (dlopen: "libc.so.6" flags: RTLD_LAZY) ^dispose

    # int open(const char *pathname, int flags, [optional] mode_t mode)
    #   (where mode_t = unsigned int)
    let: &mode_t = &ffi_type_uint # TODO: should be able to generate foreign read/write functions based on a typedef
    &open prep-ffi-call: libc symbol: "open" atypes: { &ffi_type_pointer; &ffi_type_sint; &mode_t } rtype: &ffi_type_sint

    # ssize_t read(int fd, void *buf, size_t count)
    &read prep-ffi-call: libc symbol: "read" atypes: { &ffi_type_sint; &ffi_type_pointer; &size_t } rtype: &ssize_t

    # ssize_t write(int fd, const void *buf, size_t count)
    &write prep-ffi-call: libc symbol: "write" atypes: { &ffi_type_sint; &ffi_type_pointer; &size_t } rtype: &ssize_t

    &fcntl<void> prep-ffi-call: libc symbol: "fcntl" atypes: { &ffi_type_sint; &ffi_type_sint } rtype: &ffi_type_sint
    &fcntl<int> prep-ffi-call: libc symbol: "fcntl" atypes: { &ffi_type_sint; &ffi_type_sint; &ffi_type_sint } rtype: &ffi_type_sint
    &fcntl<ptr> prep-ffi-call: libc symbol: "fcntl" atypes: { &ffi_type_sint; &ffi_type_sint; &ffi_type_pointer } rtype: &ffi_type_sint

    # TODO: ioctl
]

# =================================================================================================

# Result must be disposed later.
let: (open-handle: (pathname: String) flags: (flags: Fixnum) mode: (mode: Fixnum)) do: [
    AutoCloseFileHandle fd: (%open: pathname flags: flags mode: mode) refcnt: 0
]

let: ((handle: FileHandle) handle-read: (count: Fixnum) into: (buf: ByteArray)) do: [
    assert: count <= buf length
    buf from: 0 to<: (handle .fd %read: buf count: count at: 0)
]
# TODO: ensure this is a MutableSlice of a ByteArray specifically
let: ((handle: FileHandle) handle-read: (count: Fixnum) into: (buf: MutableSlice)) do: [
    assert: count <= buf length
    buf from: 0 to<: (handle .fd %read: buf .seq count: count at: buf .start)
]

let: ((handle: FileHandle) handle-write: (count: Fixnum) from: (buf: ByteArray)) do: [
    assert: count <= buf length
    handle .fd %write: buf count: count at: 0
]
# TODO: ensure this is a Slice of a ByteArray specifically
let: ((handle: FileHandle) handle-write: (count: Fixnum) from: (buf: Slice)) do: [
    assert: count <= buf length
    handle .fd %write: buf .seq count: count at: buf .start
]


data: FileStream extends: { Disposable } has: { handle; eof? }
let: (stream: FileStream) dispose do: [
    # Check if already disposed.
    assert: stream .handle != #null
    stream .handle remove-ref
    stream handle: #null
]

let: (stream: FileStream) latch-eof do: [
    stream eof?: #t
]

# An InputStream built around a nonblocking file handle. Supports both nonblocking and blocking operations.
data: NonBlockingFileInputStream extends: { FileStream; InputStream } has: {}
# An InputStream built around a blocking file handle. Does not support nonblocking operations.
data: BlockingFileInputStream extends: { FileStream; InputStream } has: {}

# An OutputStream built around a nonblocking file handle. Supports both nonblocking and blocking operations.
data: NonBlockingFileOutputStream extends: { FileStream; OutputStream } has: {}
# An OutputStream built around a blocking file handle. Does not support nonblocking operations.
data: BlockingFileOutputStream extends: { FileStream; OutputStream } has: {}

let: (open-input: (pathname: String)) do: [
    NonBlockingFileInputStream handle: (open-handle: pathname flags: (O_RDONLY bit|: O_NONBLOCK) mode: 0) add-ref eof?: #f
]
let: (open-input/blocking: (pathname: String)) do: [
    BlockingFileInputStream handle: (open-handle: pathname flags: O_RDONLY mode: 0) add-ref eof?: #f
]

let: (open-output: (pathname: String)) do: [
    NonBlockingFileOutputStream handle: (open-handle: pathname flags: (O_WRONLY bit|: O_NONBLOCK) mode: 0) add-ref eof?: #f
]
let: (open-output/blocking: (pathname: String)) do: [
    BlockingFileOutputStream handle: (open-handle: pathname flags: O_WRONLY mode: 0) add-ref eof?: #f
]

let: (s: NonBlockingFileInputStream) end-of-stream? do: [ s .eof? ]
let: (s: BlockingFileInputStream) end-of-stream? do: [ s .eof? ]
let: ((s: NonBlockingFileInputStream) stream-read-available: (count: Fixnum) into: (buf: MutableSequence)) do: [
    do-io: [
        let: sub-buf = (s .handle handle-read: count into: buf)
        if: count > 0 and (sub-buf length = 0) then: [ s latch-eof ]
        sub-buf
    ] if-blocked: [
        # We don't know if the file position changed, so just assume it did not.
        buf from: 0 to<: 0
    ]
]
let: (s: NonBlockingFileInputStream) stream-wait-read do: [
    epoll-suspend-fd: s .handle .fd events: EPOLLIN
]
let: ((s: BlockingFileInputStream) stream-read: (count: Fixnum) into: (buf: MutableSequence)) do: [
    let: sub-buf = (s .handle handle-read: count into: buf)
    if: count > 0 and (sub-buf length = 0) then: [ s latch-eof ]
    sub-buf
]
let: (s: NonBlockingFileInputStream) buffer-exemplar do: [ 0 zeros-byte-array ]
let: (s: BlockingFileInputStream) buffer-exemplar do: [ 0 zeros-byte-array ]

let: ((s: NonBlockingFileOutputStream) stream-write-available: (count: Fixnum) from: (buf: Sequence)) do: [
    s .handle handle-write: count from: buf
]
let: (s: NonBlockingFileOutputStream) stream-wait-write do: [
    epoll-suspend-fd: s .handle .fd events: EPOLLOUT
]
let: ((s: BlockingFileOutputStream) stream-write: (count: Fixnum) from: (buf: Sequence)) do: [
    s .handle handle-write: count from: buf
]

# =================================================================================================

let: make-input-stream do: [
    # TODO: nonblocking
    BlockingFileInputStream handle: (FileHandle fd: 0 refcnt: 0) add-ref eof?: #f
]
let: make-output-stream do: [
    # TODO: nonblocking
    BlockingFileOutputStream handle: (FileHandle fd: 1 refcnt: 0) add-ref eof?: #f
]
let: make-error-stream do: [
    # TODO: nonblocking
    BlockingFileOutputStream handle: (FileHandle fd: 2 refcnt: 0) add-ref eof?: #f
]

let: setup-standard-streams do: [
    *input-stream* set: make-input-stream
    *output-stream* set: make-output-stream
    *error-stream* set: make-error-stream
]

let: teardown-standard-streams do: [
    # TODO: set blocking again
    #null
]
