use: {
    "core.builtin.misc"
    "core.combinator"
    "core.sequence"
}

# newtype wrapper
data: CodeUnits extends: { Sequence } has: { str }
let: (s: String) code-units do: [ CodeUnits str: s ]

let: (u: CodeUnits) length do: [ u .str ~length ]
let: ((u: CodeUnits) unsafe-at: (i: Fixnum)) do: [ u .str unsafe-read-u8-at-offset: 16 + i ]

data: InvalidUTF8 extends: { Condition } has: { str }
let: ((str: String) invalid-utf8: (message: String)) do: [ InvalidUTF8 condition: "invalid-utf8" message: message stack: #null str: str ]

# newtype wrapper
data: CodePoints has: { str }
let: (s: String) code-points do: [ CodePoints str: s ]

# Returns a pair (code-point: Fixnum, num-code-points: Fixnum),
# or else signals InvalidUTF8.
let: ((u: CodeUnits) decode-code-point-at: (i: Fixnum)) do: [
    # See https://en.wikipedia.org/wiki/UTF-8 for Code point <-> UTF-8 conversion.
    let: b1 = (u at: i)
    if: b1 < 128 then: [
        # Single-unit code point.
        (b1, 1)
    ] else: [
        if: b1 < 224 then: [
            # Two-unit code point.
            if: u length <= i + 1 then: [ (u .str invalid-utf8: "truncated code point") signal ]
            let: b2 = (u at: i + 1)
            if: not (b1 >= 194) then: [ (u .str invalid-utf8: "overlong encoding") signal ]
            if: not (b2 >= 128 and b2 < 192) then: [ (u .str invalid-utf8: "code unit 2 out of range") signal ]
            ((b1 - 192) * 64 + (b2 - 128), 2)
        ] else: [
            if: b1 < 240 then: [
                # Three-unit code point.
                if: u length <= i + 2 then: [ (u .str invalid-utf8: "truncated code point") signal ]
                let: b2 = (u at: i + 1)
                let: b3 = (u at: i + 2)
                if: (b1 = 224) and not (b2 >= 144) then: [ (u .str invalid-utf8: "overlong encoding") signal ]
                if: not (b2 >= 128 and b2 < 192) then: [ (u .str invalid-utf8: "code unit 2 out of range") signal ]
                if: not (b3 >= 128 and b3 < 192) then: [ (u .str invalid-utf8: "code unit 3 out of range") signal ]
                ((b1 - 224) * 64 * 64 + (b2 - 128) * 64 + (b3 - 128), 3)
            ] else: [
                if: b1 < 248 then: [
                    # Four-unit code point.
                    if: u length <= i + 3 then: [ (u .str invalid-utf8: "truncated code point") signal ]
                    let: b2 = (u at: i + 1)
                    let: b3 = (u at: i + 2)
                    let: b4 = (u at: i + 3)
                    if: (b1 = 240) and not (b2 >= 144) then: [ (u .str invalid-utf8: "overlong encoding") signal ]
                    if: not (b2 >= 128 and b2 < 192) then: [ (u .str invalid-utf8: "code unit 2 out of range") signal ]
                    if: not (b3 >= 128 and b3 < 192) then: [ (u .str invalid-utf8: "code unit 3 out of range") signal ]
                    if: not (b4 >= 128 and b4 < 192) then: [ (u .str invalid-utf8: "code unit 4 out of range") signal ]
                    ((b1 - 240) * 64 * 64 * 64 + (b2 - 128) * 64 * 64 + (b3 - 128) * 64 + (b4 - 128), 4)
                ] else: [
                    (u .str invalid-utf8: "code unit 1 out of range") signal
                ]
            ]
        ]
    ]
]

let: ((p: CodePoints) each: body) do: [
    let: u = p .str code-units
    mut: i = 0
    while: [i < u length] do: [
        (u decode-code-point-at: i) do*: \code-point num-units [
            body call: code-point
            i: i + num-units
        ]
    ]
]

let: (s: String) verify-utf8 do: [
    s code-points each: [ #null ]
]
