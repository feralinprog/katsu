use: {
    "core.builtin.misc"
    "core.combinator"
    "core.sequence"
}

# TODO: find a better place for this... core.sequence uses core.combinator, so can't put this in core.combinator.
let: (_it switch: (cases: Sequence) from: (i: Fixnum)) do: [
    TAIL-CALL: (if: i = cases length then: [ #null ] else: [
        TAIL-CALL: (\cond body [
            TAIL-CALL: (if: (cond call: _it) then: [
                body call: _it
            ] else: [
                TAIL-CALL: (_it switch: cases from: i + 1)
            ])
        ] call*: (cases at: i))
    ])
]
let: (_it switch: (cases: Sequence)) do: [
    TAIL-CALL: (_it switch: cases from: 0)
]

# newtype wrapper
data: CodeUnits extends: { Sequence } has: { str }
let: (s: String) code-units do: [ CodeUnits str: s ]

let: (u: CodeUnits) length do: [ u .str ~length ]
let: ((u: CodeUnits) unsafe-at: (i: Fixnum)) do: [ u .str unsafe-read-u8-at-offset: 16 + i ]

data: InvalidUTF8 extends: { Condition } has: { bytes }
let: ((bytes: Sequence) invalid-utf8: (message: String)) do: [ InvalidUTF8 condition: "invalid-utf8" message: message stack: #null bytes: bytes ]

# newtype wrapper
data: CodePoints has: { str }
let: (s: String) code-points do: [ CodePoints str: s ]

# Returns a pair (code-point: Fixnum, num-code-points: Fixnum),
# or else returns (!) an InvalidUTF8 condition.
# The input sequence is expected to be a sequence of bytes (for instance, a CodeUnits instance).
let: (b: Sequence) decode-code-point do: [
    # See https://en.wikipedia.org/wiki/UTF-8 for Code point <-> UTF-8 conversion.
    let: b1 = (b at: 0)
    b1 switch: {
        # Single-unit code point:
        [it < 128], [ (b1, 1) ]
        # Two-unit code point:
        [it < 224], [
            if: b length < 2 then: [ (b invalid-utf8: "truncated code point") signal ]
            let: b2 = (b at: 1)
            if: not (b1 >= 194) then: [ (b invalid-utf8: "overlong encoding") signal ]
            if: not (b2 >= 128 and b2 < 192) then: [ (b invalid-utf8: "code unit 2 out of range") signal ]
            ((b1 - 192) * 64 + (b2 - 128), 2)
        ]
        # Three-unit code point:
        [it < 240], [
            if: b length < 3 then: [ (b invalid-utf8: "truncated code point") signal ]
            let: b2 = (b at: 1)
            let: b3 = (b at: 2)
            if: (b1 = 224) and not (b2 >= 144) then: [ (b invalid-utf8: "overlong encoding") signal ]
            if: not (b2 >= 128 and b2 < 192) then: [ (b invalid-utf8: "code unit 2 out of range") signal ]
            if: not (b3 >= 128 and b3 < 192) then: [ (b invalid-utf8: "code unit 3 out of range") signal ]
            ((b1 - 224) * 64 * 64 + (b2 - 128) * 64 + (b3 - 128), 3)
        ]
        # Four-unit code point:
        [it < 248], [
            if: b length < 4 then: [ (b invalid-utf8: "truncated code point") signal ]
            let: b2 = (b at: 1)
            let: b3 = (b at: 2)
            let: b4 = (b at: 3)
            if: (b1 = 240) and not (b2 >= 144) then: [ (b invalid-utf8: "overlong encoding") signal ]
            if: not (b2 >= 128 and b2 < 192) then: [ (b invalid-utf8: "code unit 2 out of range") signal ]
            if: not (b3 >= 128 and b3 < 192) then: [ (b invalid-utf8: "code unit 3 out of range") signal ]
            if: not (b4 >= 128 and b4 < 192) then: [ (b invalid-utf8: "code unit 4 out of range") signal ]
            ((b1 - 240) * 64 * 64 * 64 + (b2 - 128) * 64 * 64 + (b3 - 128) * 64 + (b4 - 128), 4)
        ]
        # Otherwise, invalid UTF-8:
        [#t], [
            (b invalid-utf8: "code unit 1 out of range") signal
        ]
    }
]

# Returns a pair (code-point: Fixnum, num-code-points: Fixnum),
# or else returns an InvalidUTF8 condition.
let: ((u: CodeUnits) decode-code-point-at: (i: Fixnum)) do: [
    (u from: i to<: u length) decode-code-point
]
# Returns a pair (code-point: Fixnum, num-code-points: Fixnum),
# or else signals an InvalidUTF8 condition.
let: ((u: CodeUnits) decode-code-point-at*: (i: Fixnum)) do: [
    (u decode-code-point-at: i) if*: [InvalidUTF8?] then: [ signal ] else: [ it ]
]

let: ((p: CodePoints) each: body) do: [
    let: u = p .str code-units
    mut: i = 0
    while: [i < u length] do: [
        (u decode-code-point-at: i) do*: \code-point num-units [
            body call: code-point
            i: i + num-units
        ]
    ]
]

let: (s: String) verify-utf8 do: [
    s code-points each: [ #null ]
]
