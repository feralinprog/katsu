use: {
    "core.builtin.ffi"
    "core.builtin.misc"
    "core.cleanup"
    "core.mixin"
    "core.resource"
    "core.sequence"
    "core.string"
}

# Default disposal for a foreign value is to free it.
# Specific types of foreign values should have thin wrappers to allow different disposal strategies.
let: (f: Foreign) dispose do: [ f free ]
Disposable mix-in-to: Foreign

let: (s: String) >c-string do: [
    # Null-terminate.
    let: cs = (malloc: (s length + 1))
    # TODO: memcpy / memmove
    mut: i = 0
    while: [i < s length] do: [
        cs foreign-write-u8-at-offset: i value: (s unsafe-read-u8-at-offset: 16 + i)
        i: i + 1
    ]
    cs foreign-write-u8-at-offset: i value: 0
    cs
]

data: DLOpenError extends: { Condition } has: {}
data: DLCloseError extends: { Condition } has: {}
data: DLSymbolNotFound extends: { Condition } has: { symbol }

data: DLL has: { handle }
# Note: dlopen:flags: is defined in core.builtin.ffi; this just adds another method to that multimethod.
# TODO: reexport?
let: (dlopen: (filename: String) flags: (flags: Fixnum)) do: [
    assert: dlerror = NULL
    with-disposal: [
        let: ~filename = filename >c-string ^dispose
        let: handle = (dlopen: ~filename flags: flags)
        if: handle = NULL then: [
            let: ~err = dlerror
            # There should be an error message.
            assert: ~err != NULL
            (DLOpenError condition: "dlopen-error" message: ~err c-string>string stack: #null) signal
        ]
        DLL handle: handle
    ]
]
let: (dll: DLL) dispose do: [
    assert: dlerror = NULL
    let: result = dll .handle dlclose
    if: result != 0 then: [
        let: ~err = dlerror
        # There should be an error message.
        assert: ~err != NULL
        (DLCloseError condition: "dlclose-error" message: ~err c-string>string stack: #null) signal
    ]
]
Disposable mix-in-to: DLL

let: ((dll: DLL) dlsym: (symbol: String)) do: [
    assert: dlerror = NULL
    with-disposal: [
        let: ~symbol = symbol >c-string ^dispose
        let: lookup = (dll .handle dlsym: ~symbol)
        let: ~err? = dlerror
        if: ~err? != NULL then: [
            (DLSymbolNotFound condition: "dl-symbol-not-found" message: ~err? c-string>string stack: #null symbol: symbol) signal
        ]
        lookup
    ]
]

# TODO: add an operator precedence to parser once it's implemented in-language, delete the _
let: (f: Foreign) _& do: [
    let: ptr = (malloc: sizeof-pointer)
    ptr foreign-write-foreign-at-offset: 0 value: f
    ptr
]

# Convenience class which wraps allocated argument / return value space and a libffi CIF.
data: CIFRef has: {
    cif     # passed directly to ffi-call
    fn      # C function pointer
    rvalue  # passed directly to ffi-call
    avalues # passed directly to ffi-call
    args    # for convenience: the contents of avalues as a sequence
}
let: new-CIFRef do: [ CIFRef cif: #null fn: #null rvalue: #null avalues: #null args: #null ]
# Make a libffi ffi_call(), and return the rvalue for convenience.
let: (r: CIFRef) ffi-call do: [
    ffi-call: r .cif fn: r .fn rvalue: r .rvalue avalues: r .avalues
    r .rvalue
]

let: (ffi-type: Foreign) ffi_type.size do: [
    assert: sizeof-size_t = 8
    ffi-type foreign-read-u64-at-offset: offsetof-ffi_type.size
]
let: (ffi-type: Foreign) ffi_type.alignment do: [
    assert: sizeof-ushort = 2
    ffi-type foreign-read-u16-at-offset: offsetof-ffi_type.alignment
]
let: (ffi-type: Foreign) ffi_type.type do: [
    assert: sizeof-ushort = 2
    ffi-type foreign-read-u16-at-offset: offsetof-ffi_type.type
]
let: FFI_TYPE_STRUCT = 10
let: (ffi-type: Foreign) integral? do: [
    ffi-type ffi_type.type != FFI_TYPE_STRUCT
]

let: (ffi-type: Foreign) malloc-arg do: [
    malloc: ffi-type ffi_type.size aligned: ffi-type ffi_type.alignment
]
let: (ffi-type: Foreign) malloc-ret do: [
    let: size = (
        if: ffi-type integral? then: [
            { ffi-type ffi_type.size; sizeof-ffi_arg } max
        ] else: [
            ffi-type ffi_type.size
        ]
    )
    malloc: size aligned: ffi-type ffi_type.alignment
]

# Must be called from within a with-disposal: block.
let: ((ref: CIFRef) prep-ffi-call: (dll: DLL) symbol: (symbol: String) abi: (abi: Fixnum) atypes: (atypes: Sequence) rtype: (rtype: Foreign)) do: [
    ref fn: (dll dlsym: symbol)
    let: cif = (malloc: sizeof-ffi_cif) ^dispose
    assert: (
        ffi-prep-cif: cif abi: abi nargs: atypes length rtype: rtype atypes: (
            (malloc-foreign-array: atypes) ^dispose
        )
    ) = ffi_status.FFI_OK
    ref cif: cif
    ref args: (atypes map: [ malloc-arg ^dispose ] like: {})
    ref avalues: (malloc-foreign-array: ref .args) ^dispose
    ref rvalue: rtype malloc-ret ^dispose
]
let: ((ref: CIFRef) prep-ffi-call: (dll: DLL) symbol: (symbol: String) atypes: (atypes: Sequence) rtype: (rtype: Foreign)) do: [
    ref prep-ffi-call: dll symbol: symbol abi: ffi_abi.FFI_DEFAULT_ABI atypes: atypes rtype: rtype
]

# TODO: generate these based on some sort of typedef macro
# (and also this is platform-specific)
# --------------------------------------------------------
# typedef: uchar = u8
assert: sizeof-uchar = 1
let: &uchar = &ffi_type_uchar
let: ((foreign: Foreign) foreign-read-uchar-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-u8-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-uchar-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-u8-at-offset: offset value: value
]

# typedef: schar = s8
assert: sizeof-schar = 1
let: &schar = &ffi_type_schar
let: ((foreign: Foreign) foreign-read-schar-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-s8-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-schar-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-s8-at-offset: offset value: value
]

# typedef: ushort = u16
assert: sizeof-ushort = 2
let: &ushort = &ffi_type_ushort
let: ((foreign: Foreign) foreign-read-ushort-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-u16-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-ushort-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-u16-at-offset: offset value: value
]

# typedef: sshort = s16
assert: sizeof-sshort = 2
let: &sshort = &ffi_type_sshort
let: ((foreign: Foreign) foreign-read-sshort-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-s16-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-sshort-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-s16-at-offset: offset value: value
]

# typedef: uint = u32
assert: sizeof-uint = 4
let: &uint = &ffi_type_uint
let: ((foreign: Foreign) foreign-read-uint-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-u32-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-uint-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-u32-at-offset: offset value: value
]

# typedef: sint = s32
assert: sizeof-sint = 4
let: &sint = &ffi_type_sint
let: ((foreign: Foreign) foreign-read-sint-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-s32-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-sint-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-s32-at-offset: offset value: value
]

# typedef: ulong = u64
assert: sizeof-ulong = 8
let: &ulong = &ffi_type_ulong
let: ((foreign: Foreign) foreign-read-ulong-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-u64-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-ulong-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-u64-at-offset: offset value: value
]

# typedef: slong = s64
assert: sizeof-slong = 8
let: &slong = &ffi_type_slong
let: ((foreign: Foreign) foreign-read-slong-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-s64-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-slong-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-s64-at-offset: offset value: value
]

# typedef: size_t = unsigned long
assert: sizeof-size_t = sizeof-ulong
let: &size_t = &ulong
let: ((foreign: Foreign) foreign-read-size_t-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-ulong-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-size_t-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-ulong-at-offset: offset value: value
]

# typedef: ssize_t = signed long
assert: sizeof-ssize_t = sizeof-slong
let: &ssize_t = &slong
let: ((foreign: Foreign) foreign-read-ssize_t-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-slong-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-ssize_t-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-slong-at-offset: offset value: value
]
# --------------------------------------------------------

let: to-dispose = {}
let: (f: Disposable) dispose-on-cleanup do: [
    to-dispose append: f
    f
]
current-module add-cleanup: [
    to-dispose each: [ dispose ]
]
