use: {
    "core.builtin.ffi"
    "core.builtin.misc"
    "core.cleanup"
    "core.mixin"
    "core.resource"
    "core.sequence"
    "core.sequence.string"
}

# Default disposal for a foreign value is to free it.
# Specific types of foreign values should have thin wrappers to allow different disposal strategies.
let: (f: Foreign) dispose do: [ f free ]
Disposable mix-in-to: Foreign

let: (s: String) >c-string do: [
    # Null-terminate.
    let: cu = s code-units
    let: cs = (malloc: (cu length + 1))
    # TODO: memcpy / memmove
    mut: i = 0
    while: [i < cu length] do: [
        cs foreign-write-u8-at-offset: i value: (cu unsafe-at: i)
        i: i + 1
    ]
    cs foreign-write-u8-at-offset: i value: 0
    cs
]

let: ((f: Foreign) >byte-array/length: (length: Fixnum)) do: [
    let: b = (length zeros-byte-array)
    # TODO: memcpy / memmove
    mut: i = 0
    while: [i < length] do: [
        b unsafe-write-u8-at-offset: 16 + i value: (f foreign-read-u8-at-offset: i)
        i: i + 1
    ]
    b
]

data: DLOpenError extends: { Condition } has: {}
data: DLCloseError extends: { Condition } has: {}
data: DLSymbolNotFound extends: { Condition } has: { symbol }

data: DLL has: { handle }
# Note: dlopen:flags: is defined in core.builtin.ffi; this just adds another method to that multimethod.
# TODO: reexport?
let: (dlopen: (filename: String) flags: (flags: Fixnum)) do: [
    assert: dlerror = NULL
    with-disposal: [
        let: ~filename = filename >c-string ^dispose
        let: handle = (dlopen: ~filename flags: flags)
        if: handle = NULL then: [
            let: ~err = dlerror
            # There should be an error message.
            assert: ~err != NULL
            (DLOpenError condition: "dlopen-error" message: ~err c-string>string stack: #null) signal
        ]
        DLL handle: handle
    ]
]
let: (dll: DLL) dispose do: [
    assert: dlerror = NULL
    let: result = dll .handle dlclose
    if: result != 0 then: [
        let: ~err = dlerror
        # There should be an error message.
        assert: ~err != NULL
        (DLCloseError condition: "dlclose-error" message: ~err c-string>string stack: #null) signal
    ]
]
Disposable mix-in-to: DLL

let: ((dll: DLL) dlsym: (symbol: String)) do: [
    assert: dlerror = NULL
    with-disposal: [
        let: ~symbol = symbol >c-string ^dispose
        let: lookup = (dll .handle dlsym: ~symbol)
        let: ~err? = dlerror
        if: ~err? != NULL then: [
            (DLSymbolNotFound condition: "dl-symbol-not-found" message: ~err? c-string>string stack: #null symbol: symbol) signal
        ]
        lookup
    ]
]

# TODO: add an operator precedence to parser once it's implemented in-language, delete the _
let: (f: Foreign) _& do: [
    let: ptr = (malloc: sizeof-pointer)
    ptr foreign-write-foreign-at-offset: 0 value: f
    ptr
]

# Convenience class which wraps allocated argument / return value space and a libffi CIF.
data: CIFRef has: {
    cif     # passed directly to ffi-call
    fn      # C function pointer
    rvalue  # passed directly to ffi-call
    avalues # passed directly to ffi-call
    args    # for convenience: the contents of avalues as a sequence
}
let: new-CIFRef do: [ CIFRef cif: #null fn: #null rvalue: #null avalues: #null args: #null ]
# Make a libffi ffi_call(), and return the rvalue for convenience.
let: (r: CIFRef) ffi-call do: [
    ffi-call: r .cif fn: r .fn rvalue: r .rvalue avalues: r .avalues
    r .rvalue
]

let: (ffi-type: Foreign) ffi_type.size do: [
    assert: sizeof-size_t = 8
    ffi-type foreign-read-u64-at-offset: offsetof-ffi_type.size
]
let: (ffi-type: Foreign) ffi_type.alignment do: [
    assert: sizeof-ushort = 2
    ffi-type foreign-read-u16-at-offset: offsetof-ffi_type.alignment
]
let: (ffi-type: Foreign) ffi_type.type do: [
    assert: sizeof-ushort = 2
    ffi-type foreign-read-u16-at-offset: offsetof-ffi_type.type
]
let: FFI_TYPE_STRUCT = 10
let: (ffi-type: Foreign) integral? do: [
    ffi-type ffi_type.type != FFI_TYPE_STRUCT
]

let: (ffi-type: Foreign) malloc-arg do: [
    malloc: ffi-type ffi_type.size aligned: ffi-type ffi_type.alignment
]
let: (ffi-type: Foreign) malloc-ret do: [
    let: size = (
        if: ffi-type integral? then: [
            { ffi-type ffi_type.size; sizeof-ffi_arg } max
        ] else: [
            ffi-type ffi_type.size
        ]
    )
    malloc: size aligned: ffi-type ffi_type.alignment
]

# Must be called from within a with-disposal: block.
let: ((ref: CIFRef) prep-ffi-call: (dll: DLL) symbol: (symbol: String) abi: (abi: Fixnum) atypes: (atypes: Sequence) rtype: (rtype: Foreign)) do: [
    ref fn: (dll dlsym: symbol)
    let: cif = (malloc: sizeof-ffi_cif) ^dispose
    assert: (
        ffi-prep-cif: cif abi: abi nargs: atypes length rtype: rtype atypes: (
            (malloc-foreign-array: atypes) ^dispose
        )
    ) = ffi_status.FFI_OK
    ref cif: cif
    ref args: (atypes map: [ malloc-arg ^dispose ] like: {})
    ref avalues: (malloc-foreign-array: ref .args) ^dispose
    ref rvalue: rtype malloc-ret ^dispose
]
let: ((ref: CIFRef) prep-ffi-call: (dll: DLL) symbol: (symbol: String) atypes: (atypes: Sequence) rtype: (rtype: Foreign)) do: [
    ref prep-ffi-call: dll symbol: symbol abi: ffi_abi.FFI_DEFAULT_ABI atypes: atypes rtype: rtype
]

# TODO: generate these based on some sort of typedef macro
# (and also this is platform-specific)
# --------------------------------------------------------
# typedef: uchar = u8
assert: sizeof-uchar = 1
let: &uchar = &ffi_type_uchar
let: ((foreign: Foreign) foreign-read-uchar-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-u8-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-uchar-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-u8-at-offset: offset value: value
]

# typedef: schar = s8
assert: sizeof-schar = 1
let: &schar = &ffi_type_schar
let: ((foreign: Foreign) foreign-read-schar-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-s8-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-schar-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-s8-at-offset: offset value: value
]

# typedef: ushort = u16
assert: sizeof-ushort = 2
let: &ushort = &ffi_type_ushort
let: ((foreign: Foreign) foreign-read-ushort-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-u16-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-ushort-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-u16-at-offset: offset value: value
]

# typedef: sshort = s16
assert: sizeof-sshort = 2
let: &sshort = &ffi_type_sshort
let: ((foreign: Foreign) foreign-read-sshort-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-s16-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-sshort-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-s16-at-offset: offset value: value
]

# typedef: uint = u32
assert: sizeof-uint = 4
let: &uint = &ffi_type_uint
let: ((foreign: Foreign) foreign-read-uint-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-u32-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-uint-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-u32-at-offset: offset value: value
]

# typedef: sint = s32
assert: sizeof-sint = 4
let: &sint = &ffi_type_sint
let: ((foreign: Foreign) foreign-read-sint-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-s32-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-sint-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-s32-at-offset: offset value: value
]

# typedef: ulong = u64
assert: sizeof-ulong = 8
let: &ulong = &ffi_type_ulong
let: ((foreign: Foreign) foreign-read-ulong-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-u64-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-ulong-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-u64-at-offset: offset value: value
]

# typedef: slong = s64
assert: sizeof-slong = 8
let: &slong = &ffi_type_slong
let: ((foreign: Foreign) foreign-read-slong-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-s64-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-slong-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-s64-at-offset: offset value: value
]

# typedef: size_t = unsigned long
assert: sizeof-size_t = sizeof-ulong
let: &size_t = &ulong
let: ((foreign: Foreign) foreign-read-size_t-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-ulong-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-size_t-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-ulong-at-offset: offset value: value
]

# typedef: ssize_t = signed long
assert: sizeof-ssize_t = sizeof-slong
let: &ssize_t = &slong
let: ((foreign: Foreign) foreign-read-ssize_t-at-offset: (offset: Fixnum)) do: [ foreign foreign-read-slong-at-offset: offset ]
let: ((foreign: Foreign) foreign-write-ssize_t-at-offset: (offset: Fixnum) value: (value: Fixnum)) do: [
    foreign foreign-write-slong-at-offset: offset value: value
]
# --------------------------------------------------------

# Helpers for dealing with C structs:
# (TODO: these sorts of classes / methods should be generated by macros instead, and essentially monomorphized)
# --------------------------------------------------------

data: CType has: { name; size; alignment }
data: CIntegralType extends: { CType } has: {
    ffi-type # Foreign pointer to a libffi ffi_type
}
data: CFixedArrayType extends: { CType } has: {
    elem # CType
    length # nonnegative Fixnum
}
data: CStructType extends: { CType } has: {
    fields # Sequence of CField
}
data: CUnionType extends: { CType } has: {
    variants # Sequence of CType
}
data: CField has: { name; type; offset }

let: (t: CType) alloc do: [
    malloc: t .size aligned: t .alignment
]

let: (t: CType) check-alignment do: [
    assert: (t .size multiple-of?: t .alignment)
]

let: ((a: Fixnum) align-up: (b: Fixnum)) do: [
    if: (a multiple-of?: b) then: [ a ] else: [
        (a / b + 1) * b
    ]
]

let: (t: CIntegralType) calc-packing do: [
    # Make sure the libffi ffi_type has already had its packing calculated.
    assert: t .ffi-type ffi_type.size > 0
    assert: t .ffi-type ffi_type.alignment > 0
    t size: t .ffi-type ffi_type.size
    t alignment: t .ffi-type ffi_type.alignment
    t check-alignment
    t
]
let: (t: CFixedArrayType) calc-packing do: [
    assert: t .length >= 0
    t size: t .elem .size * t .length
    t alignment: t .elem .alignment
    t check-alignment
    t
]
let: (t: CStructType) calc-packing do: [
    # NOTE: this does not work for long doubles on some ABIs.
    # (TODO: fix this, or just use libffi ffi_get_struct_offsets()...
    # it's unfortunate that fixed-length arrays aren't directly supported.)

    # Basic algorithm:
    # - struct alignment is the maximum alignment of any field
    # - each field gets padding appended to meet that field's alignment
    # - the last field gets extra padding to meet the struct's alignment

    t alignment: (t .fields map: [ .type .alignment ]) max
    let: after-last-field = (t .fields reduce: \offset field [
        field offset: offset
        (offset + field .type .size) align-up: field .type .alignment
    ] initial: 0)
    t size: (after-last-field align-up: t .alignment)
    t check-alignment
    t
]
let: (t: CUnionType) calc-packing do: [
    # Alignment of a union is max alignment of any variant.
    # Size of a union is max size of any variant, with any extra padding to meet union alignment.
    t alignment: (t .variants map: [ .alignment ]) max
    t size: ((t .variants map: [ .size ]) max align-up: t .alignment)
    t check-alignment
    t
]

let: ((name: String) integral-type: (ffi-type: Foreign)) do: [
    (CIntegralType name: name size: #null alignment: #null ffi-type: ffi-type) calc-packing
]
let: (array-type: (elem: CType) length: (length: Fixnum)) do: [
    assert: length >= 0
    let: name = (elem .name ~ "[" ~ length >string ~ "]")
    (CFixedArrayType name: name size: #null alignment: #null elem: elem length: length) calc-packing
]
let: ((name: String) struct-type: (fields: Sequence)) do: [
    assert: not fields empty?
    assert: (fields all?: [ CField? ])
    (CStructType name: name size: #null alignment: #null fields: fields) calc-packing
]
let: ((name: String) union-type: (variants: Sequence)) do: [
    assert: not variants empty?
    assert: (variants all?: [ CType? ])
    (CUnionType name: name size: #null alignment: #null variants: variants) calc-packing
]
let: ((name: String) struct-field: (type: CType)) do: [
    CField name: name type: type offset: #null
]

let: c-void = ("void" integral-type: &ffi_type_void)
let: c-uint8 = ("uint8" integral-type: &ffi_type_uint8)
let: c-sint8 = ("sint8" integral-type: &ffi_type_sint8)
let: c-uint16 = ("uint16" integral-type: &ffi_type_uint16)
let: c-sint16 = ("sint16" integral-type: &ffi_type_sint16)
let: c-uint32 = ("uint32" integral-type: &ffi_type_uint32)
let: c-sint32 = ("sint32" integral-type: &ffi_type_sint32)
let: c-uint64 = ("uint64" integral-type: &ffi_type_uint64)
let: c-sint64 = ("sint64" integral-type: &ffi_type_sint64)
let: c-float = ("float" integral-type: &ffi_type_float)
let: c-double = ("double" integral-type: &ffi_type_double)
let: c-uchar = ("uchar" integral-type: &ffi_type_uchar)
let: c-schar = ("schar" integral-type: &ffi_type_schar)
let: c-ushort = ("ushort" integral-type: &ffi_type_ushort)
let: c-sshort = ("sshort" integral-type: &ffi_type_sshort)
let: c-uint = ("uint" integral-type: &ffi_type_uint)
let: c-sint = ("sint" integral-type: &ffi_type_sint)
let: c-ulong = ("ulong" integral-type: &ffi_type_ulong)
let: c-slong = ("slong" integral-type: &ffi_type_slong)
let: c-longdouble = ("longdouble" integral-type: &ffi_type_longdouble)
let: c-pointer = ("pointer" integral-type: &ffi_type_pointer)
let: c-complex_float = ("complex_float" integral-type: &ffi_type_complex_float)
let: c-complex_double = ("complex_double" integral-type: &ffi_type_complex_double)
let: c-complex_longdouble = ("complex_longdouble" integral-type: &ffi_type_complex_longdouble)

let: c-size_t = ("size_t" integral-type: &size_t)
let: c-ssize_t = ("ssize_t" integral-type: &ssize_t)

# --------------------------------------------------------

let: to-dispose = {}
let: (f: Disposable) dispose-on-cleanup do: [
    to-dispose append: f
    f
]
current-module add-cleanup: [
    to-dispose each: [ dispose ]
]
